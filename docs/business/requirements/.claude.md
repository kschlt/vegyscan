# Requirements - AI Instructions

## Purpose

Requirements are the Single Source of Truth for WHAT the system must do (functional) and HOW WELL it must do it (non-functional).

## File Separation

### `functional.md` - WHAT
Capabilities and features the system must provide.

**Examples:**
- ✅ "System must scan ingredient lists from images"
- ✅ "System must identify E-numbers"
- ✅ "User can save products to favorites"

### `non-functional.md` - HOW WELL
Quality attributes, constraints, and cross-cutting concerns.

**Examples:**
- ✅ "Scan must complete within 2 seconds"
- ✅ "App must work offline"
- ✅ "UI must be accessible (WCAG 2.1 AA)"
- ✅ "Data must be stored locally encrypted"

## Creating Requirements

### Process
1. Determine if functional or non-functional
2. Open appropriate file
3. Add requirement with next ID
4. Link from/to related use cases and stories
5. Add priority and status

### ID Format
- Functional: `REQ-F-XXX` (e.g., REQ-F-001, REQ-F-012)
- Non-Functional: `REQ-NF-XXX` (e.g., REQ-NF-001, REQ-NF-008)

Sequential numbering, zero-padded to 3 digits.

## Requirement Structure

```markdown
### REQ-F-XXX: [Short title]

**Description:** [Clear, specific description]

**Rationale:** [Why is this needed? Business value?]

**Priority:** [Must Have | Should Have | Nice to Have]

**Status:** [Draft | Approved | Implemented | Deprecated]

**Related:**
- Use Case: [UC-YYY](../use-cases/UC-YYY-name.md)
- User Story: [US-ZZZ](../user-stories/stories.md#us-zzz)
- ADR: [ADR-NNN](../../architecture/adr/NNNN-name.md) _(if technical decision relates)_

**Acceptance Criteria:**
- [ ] [Specific, testable criterion]
```

## Content Rules

### Functional Requirements

**Include:**
- ✅ User capabilities ("User can X")
- ✅ System behaviors ("System must Y")
- ✅ Data requirements ("System stores Z")
- ✅ Business rules ("If A, then B")

**Exclude:**
- ❌ Implementation details ("Using PostgreSQL")
- ❌ UI design specifics (→ non-functional UX requirements)
- ❌ Performance metrics (→ non-functional)

### Non-Functional Requirements

**Categories:**
- Performance (speed, throughput, resource usage)
- Security (encryption, authentication, authorization)
- Usability/UX (accessibility, learnability)
- Reliability (uptime, error handling)
- Maintainability (code quality, documentation)
- Compatibility (platforms, browsers)
- Scalability (concurrent users, data growth)

**Include:**
- ✅ Measurable criteria ("Response time < 2s")
- ✅ Standards compliance ("WCAG 2.1 AA")
- ✅ Constraints ("Runs on devices with 2GB RAM")

**Exclude:**
- ❌ Technology choices (→ architecture/adr/)
- ❌ Feature descriptions (→ functional.md)

## Priority Levels

- **Must Have**: Core functionality, app unusable without
- **Should Have**: Important features, but workarounds exist
- **Nice to Have**: Enhances experience, not critical

## Status Values

- **Draft**: Being written/refined
- **Approved**: Stakeholder accepted
- **Implemented**: Feature is live
- **Deprecated**: No longer relevant

## Updating Requirements

### Allowed
- ✅ Add acceptance criteria
- ✅ Refine description for clarity
- ✅ Update status
- ✅ Add cross-references

### Requires careful review
- ⚠️ Changing priority (check impact on roadmap)
- ⚠️ Changing core description (might affect implementation)
- ⚠️ Deprecating (verify no features depend on it)

## Cross-References

Requirements are heavily referenced:
- Use cases describe HOW requirements are fulfilled
- User stories break down requirements into deliverables
- ADRs explain technology choices to meet non-functional requirements

Always maintain bidirectional links.

## Traceability

Each requirement should trace to:
- **Source**: Which use case/story/persona drove this?
- **Implementation**: Which code/components implement it?
- **Tests**: Which tests verify it?

Add this over time as implementation progresses.
